Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> list_of_functions main
Rule 2     list_of_functions -> func_init list_of_functions
Rule 3     list_of_functions -> <empty>
Rule 4     main -> MAIN BRACKET BRACKET BRACKET list_of_op BRACKET
Rule 5     func_init -> FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET
Rule 6     list_of_args -> VARIABLE SEMICOLON list_of_args
Rule 7     list_of_args -> VARIABLE
Rule 8     list_of_args -> <empty>
Rule 9     list_of_op -> operation SEMICOLON list_of_op
Rule 10    list_of_op -> <empty>
Rule 11    operation -> op_skip
Rule 12    operation -> op_if
Rule 13    operation -> op_while
Rule 14    operation -> op_bind
Rule 15    operation -> op_return
Rule 16    operation -> f_call
Rule 17    op_skip -> SKIP
Rule 18    op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
Rule 19    op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
Rule 20    op_while -> WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
Rule 21    op_bind -> VARIABLE BINDING expr
Rule 22    op_return -> RETURN expr
Rule 23    f_call -> FUNCTION BRACKET list_of_args BRACKET
Rule 24    expr -> expr_without_or OR expr
Rule 25    expr -> expr_without_or
Rule 26    expr_without_or -> expr_without_and AND expr_without_or
Rule 27    expr_without_or -> expr_without_and
Rule 28    expr_without_and -> NOT expr_without_not
Rule 29    expr_without_and -> expr_without_not
Rule 30    expr_without_not -> expr_without_compare EQUAL expr_without_compare
Rule 31    expr_without_not -> expr_without_compare NEQ expr_without_compare
Rule 32    expr_without_not -> expr_without_compare GEQ expr_without_compare
Rule 33    expr_without_not -> expr_without_compare LEQ expr_without_compare
Rule 34    expr_without_not -> expr_without_compare GT expr_without_compare
Rule 35    expr_without_not -> expr_without_compare LT expr_without_compare
Rule 36    expr_without_not -> expr_without_compare
Rule 37    expr_without_compare -> expr_without_compare PLUS expr_monomial
Rule 38    expr_without_compare -> expr_without_compare MINUS expr_monomial
Rule 39    expr_without_compare -> expr_monomial
Rule 40    expr_monomial -> expr_monomial MUL expr_indivisible
Rule 41    expr_monomial -> expr_monomial DIV expr_indivisible
Rule 42    expr_monomial -> expr_indivisible
Rule 43    expr_indivisible -> BRACKET MINUS expr_positive BRACKET
Rule 44    expr_indivisible -> expr_positive
Rule 45    expr_positive -> expr_unit POW expr_positive
Rule 46    expr_positive -> expr_unit
Rule 47    expr_unit -> NUMBER
Rule 48    expr_unit -> STRING
Rule 49    expr_unit -> VARIABLE
Rule 50    expr_unit -> f_call
Rule 51    expr_unit -> BRACKET expr BRACKET

Terminals, with rules where they appear

AND                  : 26
BINDING              : 21
BRACKET              : 4 4 4 4 5 5 5 5 18 18 18 18 18 18 19 19 19 19 20 20 20 20 23 23 43 43 51 51
DIV                  : 41
ELSE                 : 18
EQUAL                : 30
FUNCTION             : 5 23
GEQ                  : 32
GT                   : 34
IF                   : 18 19
LEQ                  : 33
LT                   : 35
MAIN                 : 4
MINUS                : 38 43
MUL                  : 40
NEQ                  : 31
NOT                  : 28
NUMBER               : 47
OR                   : 24
PLUS                 : 37
POW                  : 45
RETURN               : 22
SEMICOLON            : 6 9
SKIP                 : 17
STRING               : 48
VARIABLE             : 6 7 21 49
WHILE                : 20
error                : 

Nonterminals, with rules where they appear

expr                 : 18 19 20 21 22 24 51
expr_indivisible     : 40 41 42
expr_monomial        : 37 38 39 40 41
expr_positive        : 43 44 45
expr_unit            : 45 46
expr_without_and     : 26 27
expr_without_compare : 30 30 31 31 32 32 33 33 34 34 35 35 36 37 38
expr_without_not     : 28 29
expr_without_or      : 24 25 26
f_call               : 16 50
func_init            : 2
list_of_args         : 5 6 23
list_of_functions    : 1 2
list_of_op           : 4 5 9 18 18 19 20
main                 : 1
op_bind              : 14
op_if                : 12
op_return            : 15
op_skip              : 11
op_while             : 13
operation            : 9
program              : 0

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . list_of_functions main
    (2) list_of_functions -> . func_init list_of_functions
    (3) list_of_functions -> .
    (5) func_init -> . FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET

    MAIN            reduce using rule 3 (list_of_functions -> .)
    FUNCTION        shift and go to state 4

    program                        shift and go to state 1
    list_of_functions              shift and go to state 2
    func_init                      shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> list_of_functions . main
    (4) main -> . MAIN BRACKET BRACKET BRACKET list_of_op BRACKET

    MAIN            shift and go to state 6

    main                           shift and go to state 5

state 3

    (2) list_of_functions -> func_init . list_of_functions
    (2) list_of_functions -> . func_init list_of_functions
    (3) list_of_functions -> .
    (5) func_init -> . FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET

    MAIN            reduce using rule 3 (list_of_functions -> .)
    FUNCTION        shift and go to state 4

    func_init                      shift and go to state 3
    list_of_functions              shift and go to state 7

state 4

    (5) func_init -> FUNCTION . BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 8


state 5

    (1) program -> list_of_functions main .

    $end            reduce using rule 1 (program -> list_of_functions main .)


state 6

    (4) main -> MAIN . BRACKET BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 9


state 7

    (2) list_of_functions -> func_init list_of_functions .

    MAIN            reduce using rule 2 (list_of_functions -> func_init list_of_functions .)


state 8

    (5) func_init -> FUNCTION BRACKET . list_of_args BRACKET BRACKET list_of_op BRACKET
    (6) list_of_args -> . VARIABLE SEMICOLON list_of_args
    (7) list_of_args -> . VARIABLE
    (8) list_of_args -> .

    VARIABLE        shift and go to state 11
    BRACKET         reduce using rule 8 (list_of_args -> .)

    list_of_args                   shift and go to state 10

state 9

    (4) main -> MAIN BRACKET . BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 12


state 10

    (5) func_init -> FUNCTION BRACKET list_of_args . BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 13


state 11

    (6) list_of_args -> VARIABLE . SEMICOLON list_of_args
    (7) list_of_args -> VARIABLE .

    SEMICOLON       shift and go to state 14
    BRACKET         reduce using rule 7 (list_of_args -> VARIABLE .)


state 12

    (4) main -> MAIN BRACKET BRACKET . BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 15


state 13

    (5) func_init -> FUNCTION BRACKET list_of_args BRACKET . BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 16


state 14

    (6) list_of_args -> VARIABLE SEMICOLON . list_of_args
    (6) list_of_args -> . VARIABLE SEMICOLON list_of_args
    (7) list_of_args -> . VARIABLE
    (8) list_of_args -> .

    VARIABLE        shift and go to state 11
    BRACKET         reduce using rule 8 (list_of_args -> .)

    list_of_args                   shift and go to state 17

state 15

    (4) main -> MAIN BRACKET BRACKET BRACKET . list_of_op BRACKET
    (9) list_of_op -> . operation SEMICOLON list_of_op
    (10) list_of_op -> .
    (11) operation -> . op_skip
    (12) operation -> . op_if
    (13) operation -> . op_while
    (14) operation -> . op_bind
    (15) operation -> . op_return
    (16) operation -> . f_call
    (17) op_skip -> . SKIP
    (18) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (20) op_while -> . WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (21) op_bind -> . VARIABLE BINDING expr
    (22) op_return -> . RETURN expr
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         reduce using rule 10 (list_of_op -> .)
    SKIP            shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    VARIABLE        shift and go to state 29
    RETURN          shift and go to state 30
    FUNCTION        shift and go to state 31

    list_of_op                     shift and go to state 18
    operation                      shift and go to state 19
    op_skip                        shift and go to state 20
    op_if                          shift and go to state 21
    op_while                       shift and go to state 22
    op_bind                        shift and go to state 23
    op_return                      shift and go to state 24
    f_call                         shift and go to state 25

state 16

    (5) func_init -> FUNCTION BRACKET list_of_args BRACKET BRACKET . list_of_op BRACKET
    (9) list_of_op -> . operation SEMICOLON list_of_op
    (10) list_of_op -> .
    (11) operation -> . op_skip
    (12) operation -> . op_if
    (13) operation -> . op_while
    (14) operation -> . op_bind
    (15) operation -> . op_return
    (16) operation -> . f_call
    (17) op_skip -> . SKIP
    (18) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (20) op_while -> . WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (21) op_bind -> . VARIABLE BINDING expr
    (22) op_return -> . RETURN expr
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         reduce using rule 10 (list_of_op -> .)
    SKIP            shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    VARIABLE        shift and go to state 29
    RETURN          shift and go to state 30
    FUNCTION        shift and go to state 31

    list_of_op                     shift and go to state 32
    operation                      shift and go to state 19
    op_skip                        shift and go to state 20
    op_if                          shift and go to state 21
    op_while                       shift and go to state 22
    op_bind                        shift and go to state 23
    op_return                      shift and go to state 24
    f_call                         shift and go to state 25

state 17

    (6) list_of_args -> VARIABLE SEMICOLON list_of_args .

    BRACKET         reduce using rule 6 (list_of_args -> VARIABLE SEMICOLON list_of_args .)


state 18

    (4) main -> MAIN BRACKET BRACKET BRACKET list_of_op . BRACKET

    BRACKET         shift and go to state 33


state 19

    (9) list_of_op -> operation . SEMICOLON list_of_op

    SEMICOLON       shift and go to state 34


state 20

    (11) operation -> op_skip .

    SEMICOLON       reduce using rule 11 (operation -> op_skip .)


state 21

    (12) operation -> op_if .

    SEMICOLON       reduce using rule 12 (operation -> op_if .)


state 22

    (13) operation -> op_while .

    SEMICOLON       reduce using rule 13 (operation -> op_while .)


state 23

    (14) operation -> op_bind .

    SEMICOLON       reduce using rule 14 (operation -> op_bind .)


state 24

    (15) operation -> op_return .

    SEMICOLON       reduce using rule 15 (operation -> op_return .)


state 25

    (16) operation -> f_call .

    SEMICOLON       reduce using rule 16 (operation -> f_call .)


state 26

    (17) op_skip -> SKIP .

    SEMICOLON       reduce using rule 17 (op_skip -> SKIP .)


state 27

    (18) op_if -> IF . BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF . BRACKET expr BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 35


state 28

    (20) op_while -> WHILE . BRACKET expr BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 36


state 29

    (21) op_bind -> VARIABLE . BINDING expr

    BINDING         shift and go to state 37


state 30

    (22) op_return -> RETURN . expr
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr                           shift and go to state 38
    expr_without_or                shift and go to state 39
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 31

    (23) f_call -> FUNCTION . BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 53


state 32

    (5) func_init -> FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op . BRACKET

    BRACKET         shift and go to state 54


state 33

    (4) main -> MAIN BRACKET BRACKET BRACKET list_of_op BRACKET .

    $end            reduce using rule 4 (main -> MAIN BRACKET BRACKET BRACKET list_of_op BRACKET .)


state 34

    (9) list_of_op -> operation SEMICOLON . list_of_op
    (9) list_of_op -> . operation SEMICOLON list_of_op
    (10) list_of_op -> .
    (11) operation -> . op_skip
    (12) operation -> . op_if
    (13) operation -> . op_while
    (14) operation -> . op_bind
    (15) operation -> . op_return
    (16) operation -> . f_call
    (17) op_skip -> . SKIP
    (18) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (20) op_while -> . WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (21) op_bind -> . VARIABLE BINDING expr
    (22) op_return -> . RETURN expr
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         reduce using rule 10 (list_of_op -> .)
    SKIP            shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    VARIABLE        shift and go to state 29
    RETURN          shift and go to state 30
    FUNCTION        shift and go to state 31

    operation                      shift and go to state 19
    list_of_op                     shift and go to state 55
    op_skip                        shift and go to state 20
    op_if                          shift and go to state 21
    op_while                       shift and go to state 22
    op_bind                        shift and go to state 23
    op_return                      shift and go to state 24
    f_call                         shift and go to state 25

state 35

    (18) op_if -> IF BRACKET . expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF BRACKET . expr BRACKET BRACKET list_of_op BRACKET
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr                           shift and go to state 56
    expr_without_or                shift and go to state 39
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 36

    (20) op_while -> WHILE BRACKET . expr BRACKET BRACKET list_of_op BRACKET
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr                           shift and go to state 57
    expr_without_or                shift and go to state 39
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 37

    (21) op_bind -> VARIABLE BINDING . expr
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr                           shift and go to state 58
    expr_without_or                shift and go to state 39
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 38

    (22) op_return -> RETURN expr .

    SEMICOLON       reduce using rule 22 (op_return -> RETURN expr .)


state 39

    (24) expr -> expr_without_or . OR expr
    (25) expr -> expr_without_or .

    OR              shift and go to state 59
    SEMICOLON       reduce using rule 25 (expr -> expr_without_or .)
    BRACKET         reduce using rule 25 (expr -> expr_without_or .)


state 40

    (26) expr_without_or -> expr_without_and . AND expr_without_or
    (27) expr_without_or -> expr_without_and .

    AND             shift and go to state 60
    OR              reduce using rule 27 (expr_without_or -> expr_without_and .)
    SEMICOLON       reduce using rule 27 (expr_without_or -> expr_without_and .)
    BRACKET         reduce using rule 27 (expr_without_or -> expr_without_and .)


state 41

    (28) expr_without_and -> NOT . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_not               shift and go to state 61
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 42

    (29) expr_without_and -> expr_without_not .

    AND             reduce using rule 29 (expr_without_and -> expr_without_not .)
    OR              reduce using rule 29 (expr_without_and -> expr_without_not .)
    SEMICOLON       reduce using rule 29 (expr_without_and -> expr_without_not .)
    BRACKET         reduce using rule 29 (expr_without_and -> expr_without_not .)


state 43

    (30) expr_without_not -> expr_without_compare . EQUAL expr_without_compare
    (31) expr_without_not -> expr_without_compare . NEQ expr_without_compare
    (32) expr_without_not -> expr_without_compare . GEQ expr_without_compare
    (33) expr_without_not -> expr_without_compare . LEQ expr_without_compare
    (34) expr_without_not -> expr_without_compare . GT expr_without_compare
    (35) expr_without_not -> expr_without_compare . LT expr_without_compare
    (36) expr_without_not -> expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    EQUAL           shift and go to state 62
    NEQ             shift and go to state 63
    GEQ             shift and go to state 64
    LEQ             shift and go to state 65
    GT              shift and go to state 66
    LT              shift and go to state 67
    AND             reduce using rule 36 (expr_without_not -> expr_without_compare .)
    OR              reduce using rule 36 (expr_without_not -> expr_without_compare .)
    SEMICOLON       reduce using rule 36 (expr_without_not -> expr_without_compare .)
    BRACKET         reduce using rule 36 (expr_without_not -> expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 44

    (39) expr_without_compare -> expr_monomial .
    (40) expr_monomial -> expr_monomial . MUL expr_indivisible
    (41) expr_monomial -> expr_monomial . DIV expr_indivisible

    EQUAL           reduce using rule 39 (expr_without_compare -> expr_monomial .)
    NEQ             reduce using rule 39 (expr_without_compare -> expr_monomial .)
    GEQ             reduce using rule 39 (expr_without_compare -> expr_monomial .)
    LEQ             reduce using rule 39 (expr_without_compare -> expr_monomial .)
    GT              reduce using rule 39 (expr_without_compare -> expr_monomial .)
    LT              reduce using rule 39 (expr_without_compare -> expr_monomial .)
    PLUS            reduce using rule 39 (expr_without_compare -> expr_monomial .)
    MINUS           reduce using rule 39 (expr_without_compare -> expr_monomial .)
    AND             reduce using rule 39 (expr_without_compare -> expr_monomial .)
    OR              reduce using rule 39 (expr_without_compare -> expr_monomial .)
    SEMICOLON       reduce using rule 39 (expr_without_compare -> expr_monomial .)
    BRACKET         reduce using rule 39 (expr_without_compare -> expr_monomial .)
    MUL             shift and go to state 70
    DIV             shift and go to state 71


state 45

    (42) expr_monomial -> expr_indivisible .

    MUL             reduce using rule 42 (expr_monomial -> expr_indivisible .)
    DIV             reduce using rule 42 (expr_monomial -> expr_indivisible .)
    EQUAL           reduce using rule 42 (expr_monomial -> expr_indivisible .)
    NEQ             reduce using rule 42 (expr_monomial -> expr_indivisible .)
    GEQ             reduce using rule 42 (expr_monomial -> expr_indivisible .)
    LEQ             reduce using rule 42 (expr_monomial -> expr_indivisible .)
    GT              reduce using rule 42 (expr_monomial -> expr_indivisible .)
    LT              reduce using rule 42 (expr_monomial -> expr_indivisible .)
    PLUS            reduce using rule 42 (expr_monomial -> expr_indivisible .)
    MINUS           reduce using rule 42 (expr_monomial -> expr_indivisible .)
    AND             reduce using rule 42 (expr_monomial -> expr_indivisible .)
    OR              reduce using rule 42 (expr_monomial -> expr_indivisible .)
    SEMICOLON       reduce using rule 42 (expr_monomial -> expr_indivisible .)
    BRACKET         reduce using rule 42 (expr_monomial -> expr_indivisible .)


state 46

    (43) expr_indivisible -> BRACKET . MINUS expr_positive BRACKET
    (51) expr_unit -> BRACKET . expr BRACKET
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    MINUS           shift and go to state 72
    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_positive                  shift and go to state 47
    expr                           shift and go to state 73
    expr_without_or                shift and go to state 39
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 47

    (44) expr_indivisible -> expr_positive .

    MUL             reduce using rule 44 (expr_indivisible -> expr_positive .)
    DIV             reduce using rule 44 (expr_indivisible -> expr_positive .)
    EQUAL           reduce using rule 44 (expr_indivisible -> expr_positive .)
    NEQ             reduce using rule 44 (expr_indivisible -> expr_positive .)
    GEQ             reduce using rule 44 (expr_indivisible -> expr_positive .)
    LEQ             reduce using rule 44 (expr_indivisible -> expr_positive .)
    GT              reduce using rule 44 (expr_indivisible -> expr_positive .)
    LT              reduce using rule 44 (expr_indivisible -> expr_positive .)
    PLUS            reduce using rule 44 (expr_indivisible -> expr_positive .)
    MINUS           reduce using rule 44 (expr_indivisible -> expr_positive .)
    AND             reduce using rule 44 (expr_indivisible -> expr_positive .)
    OR              reduce using rule 44 (expr_indivisible -> expr_positive .)
    SEMICOLON       reduce using rule 44 (expr_indivisible -> expr_positive .)
    BRACKET         reduce using rule 44 (expr_indivisible -> expr_positive .)


state 48

    (45) expr_positive -> expr_unit . POW expr_positive
    (46) expr_positive -> expr_unit .

    POW             shift and go to state 74
    MUL             reduce using rule 46 (expr_positive -> expr_unit .)
    DIV             reduce using rule 46 (expr_positive -> expr_unit .)
    EQUAL           reduce using rule 46 (expr_positive -> expr_unit .)
    NEQ             reduce using rule 46 (expr_positive -> expr_unit .)
    GEQ             reduce using rule 46 (expr_positive -> expr_unit .)
    LEQ             reduce using rule 46 (expr_positive -> expr_unit .)
    GT              reduce using rule 46 (expr_positive -> expr_unit .)
    LT              reduce using rule 46 (expr_positive -> expr_unit .)
    PLUS            reduce using rule 46 (expr_positive -> expr_unit .)
    MINUS           reduce using rule 46 (expr_positive -> expr_unit .)
    AND             reduce using rule 46 (expr_positive -> expr_unit .)
    OR              reduce using rule 46 (expr_positive -> expr_unit .)
    SEMICOLON       reduce using rule 46 (expr_positive -> expr_unit .)
    BRACKET         reduce using rule 46 (expr_positive -> expr_unit .)


state 49

    (47) expr_unit -> NUMBER .

    POW             reduce using rule 47 (expr_unit -> NUMBER .)
    MUL             reduce using rule 47 (expr_unit -> NUMBER .)
    DIV             reduce using rule 47 (expr_unit -> NUMBER .)
    EQUAL           reduce using rule 47 (expr_unit -> NUMBER .)
    NEQ             reduce using rule 47 (expr_unit -> NUMBER .)
    GEQ             reduce using rule 47 (expr_unit -> NUMBER .)
    LEQ             reduce using rule 47 (expr_unit -> NUMBER .)
    GT              reduce using rule 47 (expr_unit -> NUMBER .)
    LT              reduce using rule 47 (expr_unit -> NUMBER .)
    PLUS            reduce using rule 47 (expr_unit -> NUMBER .)
    MINUS           reduce using rule 47 (expr_unit -> NUMBER .)
    AND             reduce using rule 47 (expr_unit -> NUMBER .)
    OR              reduce using rule 47 (expr_unit -> NUMBER .)
    SEMICOLON       reduce using rule 47 (expr_unit -> NUMBER .)
    BRACKET         reduce using rule 47 (expr_unit -> NUMBER .)


state 50

    (48) expr_unit -> STRING .

    POW             reduce using rule 48 (expr_unit -> STRING .)
    MUL             reduce using rule 48 (expr_unit -> STRING .)
    DIV             reduce using rule 48 (expr_unit -> STRING .)
    EQUAL           reduce using rule 48 (expr_unit -> STRING .)
    NEQ             reduce using rule 48 (expr_unit -> STRING .)
    GEQ             reduce using rule 48 (expr_unit -> STRING .)
    LEQ             reduce using rule 48 (expr_unit -> STRING .)
    GT              reduce using rule 48 (expr_unit -> STRING .)
    LT              reduce using rule 48 (expr_unit -> STRING .)
    PLUS            reduce using rule 48 (expr_unit -> STRING .)
    MINUS           reduce using rule 48 (expr_unit -> STRING .)
    AND             reduce using rule 48 (expr_unit -> STRING .)
    OR              reduce using rule 48 (expr_unit -> STRING .)
    SEMICOLON       reduce using rule 48 (expr_unit -> STRING .)
    BRACKET         reduce using rule 48 (expr_unit -> STRING .)


state 51

    (49) expr_unit -> VARIABLE .

    POW             reduce using rule 49 (expr_unit -> VARIABLE .)
    MUL             reduce using rule 49 (expr_unit -> VARIABLE .)
    DIV             reduce using rule 49 (expr_unit -> VARIABLE .)
    EQUAL           reduce using rule 49 (expr_unit -> VARIABLE .)
    NEQ             reduce using rule 49 (expr_unit -> VARIABLE .)
    GEQ             reduce using rule 49 (expr_unit -> VARIABLE .)
    LEQ             reduce using rule 49 (expr_unit -> VARIABLE .)
    GT              reduce using rule 49 (expr_unit -> VARIABLE .)
    LT              reduce using rule 49 (expr_unit -> VARIABLE .)
    PLUS            reduce using rule 49 (expr_unit -> VARIABLE .)
    MINUS           reduce using rule 49 (expr_unit -> VARIABLE .)
    AND             reduce using rule 49 (expr_unit -> VARIABLE .)
    OR              reduce using rule 49 (expr_unit -> VARIABLE .)
    SEMICOLON       reduce using rule 49 (expr_unit -> VARIABLE .)
    BRACKET         reduce using rule 49 (expr_unit -> VARIABLE .)


state 52

    (50) expr_unit -> f_call .

    POW             reduce using rule 50 (expr_unit -> f_call .)
    MUL             reduce using rule 50 (expr_unit -> f_call .)
    DIV             reduce using rule 50 (expr_unit -> f_call .)
    EQUAL           reduce using rule 50 (expr_unit -> f_call .)
    NEQ             reduce using rule 50 (expr_unit -> f_call .)
    GEQ             reduce using rule 50 (expr_unit -> f_call .)
    LEQ             reduce using rule 50 (expr_unit -> f_call .)
    GT              reduce using rule 50 (expr_unit -> f_call .)
    LT              reduce using rule 50 (expr_unit -> f_call .)
    PLUS            reduce using rule 50 (expr_unit -> f_call .)
    MINUS           reduce using rule 50 (expr_unit -> f_call .)
    AND             reduce using rule 50 (expr_unit -> f_call .)
    OR              reduce using rule 50 (expr_unit -> f_call .)
    SEMICOLON       reduce using rule 50 (expr_unit -> f_call .)
    BRACKET         reduce using rule 50 (expr_unit -> f_call .)


state 53

    (23) f_call -> FUNCTION BRACKET . list_of_args BRACKET
    (6) list_of_args -> . VARIABLE SEMICOLON list_of_args
    (7) list_of_args -> . VARIABLE
    (8) list_of_args -> .

    VARIABLE        shift and go to state 11
    BRACKET         reduce using rule 8 (list_of_args -> .)

    list_of_args                   shift and go to state 75

state 54

    (5) func_init -> FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET .

    FUNCTION        reduce using rule 5 (func_init -> FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET .)
    MAIN            reduce using rule 5 (func_init -> FUNCTION BRACKET list_of_args BRACKET BRACKET list_of_op BRACKET .)


state 55

    (9) list_of_op -> operation SEMICOLON list_of_op .

    BRACKET         reduce using rule 9 (list_of_op -> operation SEMICOLON list_of_op .)


state 56

    (18) op_if -> IF BRACKET expr . BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF BRACKET expr . BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 76


state 57

    (20) op_while -> WHILE BRACKET expr . BRACKET BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 77


state 58

    (21) op_bind -> VARIABLE BINDING expr .

    SEMICOLON       reduce using rule 21 (op_bind -> VARIABLE BINDING expr .)


state 59

    (24) expr -> expr_without_or OR . expr
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_or                shift and go to state 39
    expr                           shift and go to state 78
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 60

    (26) expr_without_or -> expr_without_and AND . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_and               shift and go to state 40
    expr_without_or                shift and go to state 79
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 61

    (28) expr_without_and -> NOT expr_without_not .

    AND             reduce using rule 28 (expr_without_and -> NOT expr_without_not .)
    OR              reduce using rule 28 (expr_without_and -> NOT expr_without_not .)
    SEMICOLON       reduce using rule 28 (expr_without_and -> NOT expr_without_not .)
    BRACKET         reduce using rule 28 (expr_without_and -> NOT expr_without_not .)


state 62

    (30) expr_without_not -> expr_without_compare EQUAL . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_compare           shift and go to state 80
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 63

    (31) expr_without_not -> expr_without_compare NEQ . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_compare           shift and go to state 81
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 64

    (32) expr_without_not -> expr_without_compare GEQ . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_compare           shift and go to state 82
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 65

    (33) expr_without_not -> expr_without_compare LEQ . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_compare           shift and go to state 83
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 66

    (34) expr_without_not -> expr_without_compare GT . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_compare           shift and go to state 84
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 67

    (35) expr_without_not -> expr_without_compare LT . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_without_compare           shift and go to state 85
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 68

    (37) expr_without_compare -> expr_without_compare PLUS . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_monomial                  shift and go to state 86
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 69

    (38) expr_without_compare -> expr_without_compare MINUS . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_monomial                  shift and go to state 87
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 70

    (40) expr_monomial -> expr_monomial MUL . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_indivisible               shift and go to state 88
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 71

    (41) expr_monomial -> expr_monomial DIV . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr_indivisible               shift and go to state 89
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 72

    (43) expr_indivisible -> BRACKET MINUS . expr_positive BRACKET
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    BRACKET         shift and go to state 90
    FUNCTION        shift and go to state 31

    expr_positive                  shift and go to state 91
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 73

    (51) expr_unit -> BRACKET expr . BRACKET

    BRACKET         shift and go to state 92


state 74

    (45) expr_positive -> expr_unit POW . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    BRACKET         shift and go to state 90
    FUNCTION        shift and go to state 31

    expr_unit                      shift and go to state 48
    expr_positive                  shift and go to state 93
    f_call                         shift and go to state 52

state 75

    (23) f_call -> FUNCTION BRACKET list_of_args . BRACKET

    BRACKET         shift and go to state 94


state 76

    (18) op_if -> IF BRACKET expr BRACKET . BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF BRACKET expr BRACKET . BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 95


state 77

    (20) op_while -> WHILE BRACKET expr BRACKET . BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 96


state 78

    (24) expr -> expr_without_or OR expr .

    SEMICOLON       reduce using rule 24 (expr -> expr_without_or OR expr .)
    BRACKET         reduce using rule 24 (expr -> expr_without_or OR expr .)


state 79

    (26) expr_without_or -> expr_without_and AND expr_without_or .

    OR              reduce using rule 26 (expr_without_or -> expr_without_and AND expr_without_or .)
    SEMICOLON       reduce using rule 26 (expr_without_or -> expr_without_and AND expr_without_or .)
    BRACKET         reduce using rule 26 (expr_without_or -> expr_without_and AND expr_without_or .)


state 80

    (30) expr_without_not -> expr_without_compare EQUAL expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    AND             reduce using rule 30 (expr_without_not -> expr_without_compare EQUAL expr_without_compare .)
    OR              reduce using rule 30 (expr_without_not -> expr_without_compare EQUAL expr_without_compare .)
    SEMICOLON       reduce using rule 30 (expr_without_not -> expr_without_compare EQUAL expr_without_compare .)
    BRACKET         reduce using rule 30 (expr_without_not -> expr_without_compare EQUAL expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 81

    (31) expr_without_not -> expr_without_compare NEQ expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    AND             reduce using rule 31 (expr_without_not -> expr_without_compare NEQ expr_without_compare .)
    OR              reduce using rule 31 (expr_without_not -> expr_without_compare NEQ expr_without_compare .)
    SEMICOLON       reduce using rule 31 (expr_without_not -> expr_without_compare NEQ expr_without_compare .)
    BRACKET         reduce using rule 31 (expr_without_not -> expr_without_compare NEQ expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 82

    (32) expr_without_not -> expr_without_compare GEQ expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    AND             reduce using rule 32 (expr_without_not -> expr_without_compare GEQ expr_without_compare .)
    OR              reduce using rule 32 (expr_without_not -> expr_without_compare GEQ expr_without_compare .)
    SEMICOLON       reduce using rule 32 (expr_without_not -> expr_without_compare GEQ expr_without_compare .)
    BRACKET         reduce using rule 32 (expr_without_not -> expr_without_compare GEQ expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 83

    (33) expr_without_not -> expr_without_compare LEQ expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    AND             reduce using rule 33 (expr_without_not -> expr_without_compare LEQ expr_without_compare .)
    OR              reduce using rule 33 (expr_without_not -> expr_without_compare LEQ expr_without_compare .)
    SEMICOLON       reduce using rule 33 (expr_without_not -> expr_without_compare LEQ expr_without_compare .)
    BRACKET         reduce using rule 33 (expr_without_not -> expr_without_compare LEQ expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 84

    (34) expr_without_not -> expr_without_compare GT expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    AND             reduce using rule 34 (expr_without_not -> expr_without_compare GT expr_without_compare .)
    OR              reduce using rule 34 (expr_without_not -> expr_without_compare GT expr_without_compare .)
    SEMICOLON       reduce using rule 34 (expr_without_not -> expr_without_compare GT expr_without_compare .)
    BRACKET         reduce using rule 34 (expr_without_not -> expr_without_compare GT expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 85

    (35) expr_without_not -> expr_without_compare LT expr_without_compare .
    (37) expr_without_compare -> expr_without_compare . PLUS expr_monomial
    (38) expr_without_compare -> expr_without_compare . MINUS expr_monomial

    AND             reduce using rule 35 (expr_without_not -> expr_without_compare LT expr_without_compare .)
    OR              reduce using rule 35 (expr_without_not -> expr_without_compare LT expr_without_compare .)
    SEMICOLON       reduce using rule 35 (expr_without_not -> expr_without_compare LT expr_without_compare .)
    BRACKET         reduce using rule 35 (expr_without_not -> expr_without_compare LT expr_without_compare .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 86

    (37) expr_without_compare -> expr_without_compare PLUS expr_monomial .
    (40) expr_monomial -> expr_monomial . MUL expr_indivisible
    (41) expr_monomial -> expr_monomial . DIV expr_indivisible

    EQUAL           reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    NEQ             reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    GEQ             reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    LEQ             reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    GT              reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    LT              reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    PLUS            reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    MINUS           reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    AND             reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    OR              reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    SEMICOLON       reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    BRACKET         reduce using rule 37 (expr_without_compare -> expr_without_compare PLUS expr_monomial .)
    MUL             shift and go to state 70
    DIV             shift and go to state 71


state 87

    (38) expr_without_compare -> expr_without_compare MINUS expr_monomial .
    (40) expr_monomial -> expr_monomial . MUL expr_indivisible
    (41) expr_monomial -> expr_monomial . DIV expr_indivisible

    EQUAL           reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    NEQ             reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    GEQ             reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    LEQ             reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    GT              reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    LT              reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    PLUS            reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    MINUS           reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    AND             reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    OR              reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    SEMICOLON       reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    BRACKET         reduce using rule 38 (expr_without_compare -> expr_without_compare MINUS expr_monomial .)
    MUL             shift and go to state 70
    DIV             shift and go to state 71


state 88

    (40) expr_monomial -> expr_monomial MUL expr_indivisible .

    MUL             reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    DIV             reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    EQUAL           reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    NEQ             reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    GEQ             reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    LEQ             reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    GT              reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    LT              reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    PLUS            reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    MINUS           reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    AND             reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    OR              reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    SEMICOLON       reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)
    BRACKET         reduce using rule 40 (expr_monomial -> expr_monomial MUL expr_indivisible .)


state 89

    (41) expr_monomial -> expr_monomial DIV expr_indivisible .

    MUL             reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    DIV             reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    EQUAL           reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    NEQ             reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    GEQ             reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    LEQ             reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    GT              reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    LT              reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    PLUS            reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    MINUS           reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    AND             reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    OR              reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    SEMICOLON       reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)
    BRACKET         reduce using rule 41 (expr_monomial -> expr_monomial DIV expr_indivisible .)


state 90

    (51) expr_unit -> BRACKET . expr BRACKET
    (24) expr -> . expr_without_or OR expr
    (25) expr -> . expr_without_or
    (26) expr_without_or -> . expr_without_and AND expr_without_or
    (27) expr_without_or -> . expr_without_and
    (28) expr_without_and -> . NOT expr_without_not
    (29) expr_without_and -> . expr_without_not
    (30) expr_without_not -> . expr_without_compare EQUAL expr_without_compare
    (31) expr_without_not -> . expr_without_compare NEQ expr_without_compare
    (32) expr_without_not -> . expr_without_compare GEQ expr_without_compare
    (33) expr_without_not -> . expr_without_compare LEQ expr_without_compare
    (34) expr_without_not -> . expr_without_compare GT expr_without_compare
    (35) expr_without_not -> . expr_without_compare LT expr_without_compare
    (36) expr_without_not -> . expr_without_compare
    (37) expr_without_compare -> . expr_without_compare PLUS expr_monomial
    (38) expr_without_compare -> . expr_without_compare MINUS expr_monomial
    (39) expr_without_compare -> . expr_monomial
    (40) expr_monomial -> . expr_monomial MUL expr_indivisible
    (41) expr_monomial -> . expr_monomial DIV expr_indivisible
    (42) expr_monomial -> . expr_indivisible
    (43) expr_indivisible -> . BRACKET MINUS expr_positive BRACKET
    (44) expr_indivisible -> . expr_positive
    (45) expr_positive -> . expr_unit POW expr_positive
    (46) expr_positive -> . expr_unit
    (47) expr_unit -> . NUMBER
    (48) expr_unit -> . STRING
    (49) expr_unit -> . VARIABLE
    (50) expr_unit -> . f_call
    (51) expr_unit -> . BRACKET expr BRACKET
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    NOT             shift and go to state 41
    BRACKET         shift and go to state 46
    NUMBER          shift and go to state 49
    STRING          shift and go to state 50
    VARIABLE        shift and go to state 51
    FUNCTION        shift and go to state 31

    expr                           shift and go to state 73
    expr_without_or                shift and go to state 39
    expr_without_and               shift and go to state 40
    expr_without_not               shift and go to state 42
    expr_without_compare           shift and go to state 43
    expr_monomial                  shift and go to state 44
    expr_indivisible               shift and go to state 45
    expr_positive                  shift and go to state 47
    expr_unit                      shift and go to state 48
    f_call                         shift and go to state 52

state 91

    (43) expr_indivisible -> BRACKET MINUS expr_positive . BRACKET

    BRACKET         shift and go to state 97


state 92

    (51) expr_unit -> BRACKET expr BRACKET .

    POW             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    MUL             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    DIV             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    EQUAL           reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    NEQ             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    GEQ             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    LEQ             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    GT              reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    LT              reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    PLUS            reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    MINUS           reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    AND             reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    OR              reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    SEMICOLON       reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)
    BRACKET         reduce using rule 51 (expr_unit -> BRACKET expr BRACKET .)


state 93

    (45) expr_positive -> expr_unit POW expr_positive .

    MUL             reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    DIV             reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    EQUAL           reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    NEQ             reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    GEQ             reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    LEQ             reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    GT              reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    LT              reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    PLUS            reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    MINUS           reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    AND             reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    OR              reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    SEMICOLON       reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)
    BRACKET         reduce using rule 45 (expr_positive -> expr_unit POW expr_positive .)


state 94

    (23) f_call -> FUNCTION BRACKET list_of_args BRACKET .

    SEMICOLON       reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    POW             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    MUL             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    DIV             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    EQUAL           reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    NEQ             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    GEQ             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    LEQ             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    GT              reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    LT              reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    PLUS            reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    MINUS           reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    AND             reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    OR              reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)
    BRACKET         reduce using rule 23 (f_call -> FUNCTION BRACKET list_of_args BRACKET .)


state 95

    (18) op_if -> IF BRACKET expr BRACKET BRACKET . list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF BRACKET expr BRACKET BRACKET . list_of_op BRACKET
    (9) list_of_op -> . operation SEMICOLON list_of_op
    (10) list_of_op -> .
    (11) operation -> . op_skip
    (12) operation -> . op_if
    (13) operation -> . op_while
    (14) operation -> . op_bind
    (15) operation -> . op_return
    (16) operation -> . f_call
    (17) op_skip -> . SKIP
    (18) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (20) op_while -> . WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (21) op_bind -> . VARIABLE BINDING expr
    (22) op_return -> . RETURN expr
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         reduce using rule 10 (list_of_op -> .)
    SKIP            shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    VARIABLE        shift and go to state 29
    RETURN          shift and go to state 30
    FUNCTION        shift and go to state 31

    list_of_op                     shift and go to state 98
    operation                      shift and go to state 19
    op_skip                        shift and go to state 20
    op_if                          shift and go to state 21
    op_while                       shift and go to state 22
    op_bind                        shift and go to state 23
    op_return                      shift and go to state 24
    f_call                         shift and go to state 25

state 96

    (20) op_while -> WHILE BRACKET expr BRACKET BRACKET . list_of_op BRACKET
    (9) list_of_op -> . operation SEMICOLON list_of_op
    (10) list_of_op -> .
    (11) operation -> . op_skip
    (12) operation -> . op_if
    (13) operation -> . op_while
    (14) operation -> . op_bind
    (15) operation -> . op_return
    (16) operation -> . f_call
    (17) op_skip -> . SKIP
    (18) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (20) op_while -> . WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (21) op_bind -> . VARIABLE BINDING expr
    (22) op_return -> . RETURN expr
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         reduce using rule 10 (list_of_op -> .)
    SKIP            shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    VARIABLE        shift and go to state 29
    RETURN          shift and go to state 30
    FUNCTION        shift and go to state 31

    list_of_op                     shift and go to state 99
    operation                      shift and go to state 19
    op_skip                        shift and go to state 20
    op_if                          shift and go to state 21
    op_while                       shift and go to state 22
    op_bind                        shift and go to state 23
    op_return                      shift and go to state 24
    f_call                         shift and go to state 25

state 97

    (43) expr_indivisible -> BRACKET MINUS expr_positive BRACKET .

    MUL             reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    DIV             reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    EQUAL           reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    NEQ             reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    GEQ             reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    LEQ             reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    GT              reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    LT              reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    PLUS            reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    MINUS           reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    AND             reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    OR              reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    SEMICOLON       reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)
    BRACKET         reduce using rule 43 (expr_indivisible -> BRACKET MINUS expr_positive BRACKET .)


state 98

    (18) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op . BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op . BRACKET

    BRACKET         shift and go to state 100


state 99

    (20) op_while -> WHILE BRACKET expr BRACKET BRACKET list_of_op . BRACKET

    BRACKET         shift and go to state 101


state 100

    (18) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET . ELSE BRACKET list_of_op BRACKET
    (19) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET .

    ELSE            shift and go to state 102
    SEMICOLON       reduce using rule 19 (op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET .)


state 101

    (20) op_while -> WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET .

    SEMICOLON       reduce using rule 20 (op_while -> WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET .)


state 102

    (18) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE . BRACKET list_of_op BRACKET

    BRACKET         shift and go to state 103


state 103

    (18) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET . list_of_op BRACKET
    (9) list_of_op -> . operation SEMICOLON list_of_op
    (10) list_of_op -> .
    (11) operation -> . op_skip
    (12) operation -> . op_if
    (13) operation -> . op_while
    (14) operation -> . op_bind
    (15) operation -> . op_return
    (16) operation -> . f_call
    (17) op_skip -> . SKIP
    (18) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET
    (19) op_if -> . IF BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (20) op_while -> . WHILE BRACKET expr BRACKET BRACKET list_of_op BRACKET
    (21) op_bind -> . VARIABLE BINDING expr
    (22) op_return -> . RETURN expr
    (23) f_call -> . FUNCTION BRACKET list_of_args BRACKET

    BRACKET         reduce using rule 10 (list_of_op -> .)
    SKIP            shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    VARIABLE        shift and go to state 29
    RETURN          shift and go to state 30
    FUNCTION        shift and go to state 31

    list_of_op                     shift and go to state 104
    operation                      shift and go to state 19
    op_skip                        shift and go to state 20
    op_if                          shift and go to state 21
    op_while                       shift and go to state 22
    op_bind                        shift and go to state 23
    op_return                      shift and go to state 24
    f_call                         shift and go to state 25

state 104

    (18) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op . BRACKET

    BRACKET         shift and go to state 105


state 105

    (18) op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET .

    SEMICOLON       reduce using rule 18 (op_if -> IF BRACKET expr BRACKET BRACKET list_of_op BRACKET ELSE BRACKET list_of_op BRACKET .)

